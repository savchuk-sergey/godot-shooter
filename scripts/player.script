-- function init(self)
-- 	self.direction = go.get_rotation()
-- 	self.rot = vmath.quat()
-- 	-- Base rotations half a lap in each direction
-- 	self.rot_left = vmath.quat_rotation_z(3.14159)
-- 	self.rot_right = vmath.quat_rotation_z(-3.14159)
-- 	
-- 	-- Получаем фокус ввода
-- 	-- msg.post(".", "acquire_input_focus")
-- 	self.speed = 200  -- Скорость движения игрока (пиксели в секунду)
-- 	self.target_position = nil  -- Целевая позиция, куда должен двигаться игрок
-- 	self.correction = vmath.vector3()
-- 	self.hp = 10 
-- 
-- 	print("Скрипт инициализирован. Скорость: " .. self.speed)
-- end
-- 
-- function update(self, dt)
-- 	-- self.direction = vmath.slerp(dt * self.speed, self.direction, self.direction * self.rot)
-- 	-- go.set_rotation(self.direction)
-- 	-- self.rot = vmath.quat()
-- 	
-- 	self.correction = vmath.vector3()
-- 
-- 	-- Обработка отбрасывания
-- 	if self.knockback then
-- 		local current_position = go.get_position()
-- 		local movement = self.knockback_velocity * dt
-- 		go.set_position(current_position + movement)
-- 		self.knockback_time = self.knockback_time + dt
-- 		if self.knockback_time >= self.knockback_duration then
-- 			self.knockback = false
-- 			self.knockback_velocity = vmath.vector3(0, 0, 0)
-- 			self.knockback_time = 0
-- 			print("Отбрасывание завершено")
-- 		end
-- 	else
-- 		-- Обычное движение к целевой позиции
-- 		if self.target_position then
-- 			local current_position = go.get_position()
-- 			local direction = self.target_position - current_position
-- 			local distance = vmath.length(direction)
-- 
-- 			if distance > 1 then
-- 				direction = vmath.normalize(direction)
-- 				local movement = direction * self.speed * dt
-- 				go.set_position(current_position + movement)
-- 			else
-- 				self.target_position = nil
-- 			end
-- 		end
-- 	end
-- 
-- 	-- Обновление таймера неуязвимости
-- 	if self.invincible then
-- 		self.invincible_time = self.invincible_time + dt
-- 		if self.invincible_time >= self.invincible_duration then
-- 			self.invincible = false
-- 			self.invincible_time = 0
-- 			print("Игрок больше не неуязвим")
-- 		end
-- 	end
-- end
-- 
-- 
-- function on_input(self, action_id, action)
-- 	if self.knockback then
-- 		-- Игрок не может управлять во время отбрасывания
-- 		return
-- 	end
-- 
-- 	-- if action_id == hash("touch") then
-- 	-- 	if action.pressed or action.repeated then
-- 	-- 		go.cancel_animations(".", "position")
-- 	-- 		local action_pos = vmath.vector3(action.x, action.y, 0)
-- 	-- 		go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, action_pos, go.EASING_OUTCUBIC, 1)
-- 	-- 	elseif action.released then
-- 	-- 	-- Останавливаем движение, когда касание отпущено
-- 	-- 		go.cancel_animations(".", "position")
-- 	-- 	end
-- 	-- end
-- 
-- -- 	if action_id == hash("touch") then
-- -- 		if action.pressed or action.repeated then
-- -- 			-- Получаем позицию касания
-- -- 			local touch_position = vmath.vector3(action.x, action.y, 0)
-- -- 			-- Конвертируем позицию из экрана в мир (учитывайте камеру, если используете её)
-- -- 			local world_position = go.get_world_position()
-- -- 			world_position.x = touch_position.x
-- -- 			world_position.y = touch_position.y
-- -- 			self.target_position = world_position
-- -- 
-- -- 			-- Рассчитываем угол между текущей позицией и позицией касания
-- -- 			local current_position = go.get_position()
-- -- 			local angle = math.atan2(world_position.y - current_position.y, world_position.x - current_position.x) 
-- -- 			-- Поворачиваем спрайт игрока
-- -- 			local rotation = vmath.quat_rotation_z(angle)
-- -- 			go.set_rotation(rotation)
-- -- 		elseif action.released then
-- -- 			-- Останавливаем движение, когда касание отпущено
-- -- 			self.target_position = nil
-- -- 		end
-- -- 	end
-- end
-- 
-- function on_message(self, message_id, message, sender)
-- 	if message_id == hash("move") then
-- 		if message.released then
-- 			self.speed.x = 0
-- 			self.speed.y = 0
-- 		else
-- 			self.speed.x = message.x * 200
-- 			self.speed.y = message.y * 200
-- 		end
-- 	end
-- 	
-- 	-- Обработка столкновений
-- 	if message_id == hash("contact_point_response") then
-- 		go.cancel_animations(".", "position")
-- 		-- Коррекция позиции для предотвращения прохождения через объекты
-- 		if message.distance > 0 then
-- 			local proj = vmath.project(self.correction, message.normal * message.distance)
-- 			if proj < 1 then
-- 				local comp = (message.distance - message.distance * proj) * message.normal
-- 				go.set_position(go.get_position() + comp)
-- 				self.correction = self.correction + comp
-- 			end
-- 		end
-- 
-- 		-- Сохраняем нормаль столкновения для использования в случае нулевого направления
-- 		self.last_collision_normal = message.normal
-- 
-- 		if message.group == hash("enemy") then
-- 			if not self.invincible then
-- 				-- Уменьшаем здоровье на 1
-- 				self.hp = self.hp - 1
-- 				print("Столкновение с врагом! HP:", self.hp)
-- 
-- 				-- Отправляем сообщение на обновление UI
-- 				msg.post("main:/gui#health", "update_hp", { hp = self.hp })
-- 
-- 				local pos = go.get_position()
-- 				-- set a pushback direction based on the collision normal
-- 				local to = pos + message.normal * 60
-- 				-- knockback animation, then continue moving
-- 				go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, to, go.EASING_OUTQUAD, 0.1)
-- 
-- -- 				-- Вычисляем направление отбрасывания (от врага к игроку)
-- -- 				local enemy_position = go.get_position(message.other_id)
-- -- 				local player_position = go.get_position()
-- -- 				local knockback_direction = player_position - enemy_position
-- -- 
-- -- 				-- Проверяем, что направление не нулевое
-- -- 				if vmath.length_sqr(knockback_direction) == 0 then
-- -- 					-- Если нулевое, используем нормаль столкновения
-- -- 					knockback_direction = message.normal
-- -- 					print("Направление отбрасывания нулевое, используем нормаль столкновения:", knockback_direction)
-- -- 				end
-- -- 
-- -- 				-- Применяем отбрасывание
-- -- 				apply_knockback(self, knockback_direction, 500)  -- Настройте силу отбрасывания по желанию
-- -- 
-- -- 				-- Включаем неуязвимость
-- -- 				self.invincible = true
-- -- 				self.invincible_time = 0
-- -- 				print("Игрок теперь неуязвим на", self.invincible_duration, "секунд")
-- 			else
-- 				print("Игрок неуязвим, урон не получен")
-- 			end
-- 		end
-- 	end
-- end

local HASH_MOVE = hash("move")
local MOVE_SPEED = 200

function init(self)
	self.speed = vmath.vector3()
	self.look_at = 0
	self.position = go.get_position()
	self.correction = vmath.vector3()
end

function update(self, dt)
	self.position = self.position + self.speed * dt
	go.set_position(self.position)

	go.set_rotation(vmath.quat_rotation_z(self.look_at))
end

function on_message(self, message_id, message, sender)
	if message_id == HASH_MOVE then
		if message.released then
			self.speed = vmath.vector3()
		else
			local dx, dy = message.x, message.y
			print("message: " .. tostring(message.x) .. " " .. tostring(message.y))

			self.look_at = -math.atan2(dx, dy)
			self.speed = vmath.vector3(dx, dy, 0) * MOVE_SPEED
		end
	end
end